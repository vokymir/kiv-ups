\documentclass[czech, kiv, he, sem, pdf, viewonly]{fasthesis}

\usepackage{pdfpages}

\usepackage{float}

\title{Karetní hra prší pro dva hráče realizovaná nad TCP}

\author{Jakub}{Vokoun}{}{}

\nobastardtitle \nocopyrightnotice

\begin{document} \frontpages[notm]

\tableofcontents

\chapter{Zadání}

Pro karetní hru prší, v konkrétních pravidlech: nedá se přebíjet sedmička ani
eso, měnič mění pouze na svojí barvu, naprogramujte server v jazyce C nebo C++
spustitelný běžnými nástroji na OS GNU/Linux. Vytvořte klienta v jiném jazyce
(zvolen Python) jako přenositelnou aplikaci, která podporuje GNU/Linux i MS
Windows.

Síťová hra pro více hráčů s architekturou 1:N (server - klienti) fungující nad
protokolem TCP, za použití standardních BSD socketů. Cílem semestrální práce je
fungující aplikace s dobrým návrhem protokolu a jeho implementací.

\chapter{Protokol}

Komunikace mezi serverem a klientem není řízená celou dobu z jedné strany.
Samotná hra je iniciovaná a řízená serverem, pohyb klienta po serveru je řízen
klientem.

Klient se může v jednu chvíli nacházet pouze v jednom stavu. Stavy jsou
následující:

\begin{itemize}

    \item unnamed: Nepojmenovaný klient, pouze připojen na server.

    \item lobby: Pojmenovaný klient, který se může připojit do místností.

    \item room: Pojmenovaný klient v místnosti, čeká na její zaplnění.

    \item game: Pojmenovaný klient v místnost hraje/dohrál hru.

\end{itemize}


\begin{figure}[H]

    \centering

    \includegraphics[width=0.5\textwidth]{img/protocol_flow.pdf}

    \caption{Průchod klienta serverem.}

    \label{fig:protocol_flow}

\end{figure}

Každá existující místnost se musí nacházet v jednom ze stavů: OPEN, PLAYING,
FINISHED. Přičemž stav OPEN znamená, že je volné místo pro dalšího hráče, stav
PLAYING že probíhá hra, a stav FINISHED, že hra byla ukončena, ale ještě
nejméně jeden klient neopustil místnost.

Zprávy v protokolu mají proměnnou délku, v závislosti jak na typu zprávy, tak i
na přenášených datech. Protokol používá lidsky čitelná anglická slova psaná
velkými písmeny. Jednotlivé části zprávy jsou odděleny mezerou, zprávy jsou od
sebe odděleny znakem |. Každá zpráva začíná tzv. magickem PRSI. Protokol vypadá
následovně:

Formát zprávy:

\begin{center}

    \textbf{PRSI ... |}

\end{center}


\input{partials/protocol.tex}

Poznámky k protokolu:

\begin{itemize}

    \item Výběr jména nemůže neuspět, jelikož pokud si klient zvolí jméno
        stejné, jako již existující hráč, server předpokládá změnu koncového
        zařízení klienta a hráči nastaví nový FD, tedy přiřadí hráče novému
        socketu.

    \item Zprávy ze serveru o stavu klienta mohou být velice dlouhé, zvlášť
        pokud je ve hře. Vyjde to ale levněji, než posílat tři zprávy zvlášť,
        kvůli magicu a oddělovači.

    \item Na jméno hráče nejsou kladeny žádné požadavky, kromě toho, že nesmí
        obsahovat oddělovač (|) a bílé znaky. To také znamená, že dlouhé jméno
        hráče může významně zpomalit přenos. (teoreticky) Útočníci s dlouhým
        jménem by mohli naschvál způsobovat krátkou nedostupnost a opět se
        připojovat a tím saturovat síť oběti, protože obě tyto zprávy obsahují
        jméno klienta.

\end{itemize}

\chapter{Technická dokumentace implementace}

\section{Server}

Třída config zajišťuje načtení proměnných z konfiguračního souboru a výchozí
hodnoty. Třída logger nabízí možnost vypsat jakoukoliv zprávu i podle její
vážnosti (error, info, warn).

Třídy room, card a player se starají hlavně o herní logiku a tolik se
nezajímají o síť. Není to dokonalá dekompozice, v playerovi jsou uloženy
důležité informace (např. čas posledního pingu) a některé pomocné funkce, ale
ty jsou zpravidla volány ze třídy server. Původní plán byl rozdělit třídu
player na třídy player a client, což mělo lepší dekompozici, ale nedokázal jsem
to pořádně uchopit, tak je to dohromady.

Hlavní operativní třídou je server, pomocná pro ní je protocol. Protocol
vytváří zprávy k odeslání centralizovaně. Server při inicializaci vytvoří
epoll, který se kontroluje ve funkci run.

Vstupním bodem je funkce main, která vytvoří server a naplní ho daty z configu.



\section{Klient}

Klient je implementován jako python modul, v adresáři \filename{prsi}. Je volán
z vnějšku, ze souboru \filename{run.py}. Základem je třída Client, která
vlastní Ui a Net. Aplikace funguje na dvou vláknech: Ui a Net.

Pro Ui je použit tKinter, nad kterým je vystavěno uživatelské rozhraní se všemi
tlačítky apod. Hrací karty jsou velmi odlišné od standardních (kreslila je
kamarádka), ale mají stejné funkce jako standardní; načítají se pomocí třídy
Img\_Loader, která je ve třídě Ui.

Komunikace mezi ui a net třídami je zajištěna dvěma způsoby: třída net si sice
vytáří nové vlákno na síťové poslouchání, ale její metody se dají normálně
volat - takže například posílání síťových zpráv jde jednoduše. Komunikace
směrem ze sítě (z vlákna) do klienta/ui je přes frontu zpráv, do které vlákno
přidává a klient pravidelně kontroluje.

V souboru \filename{config.py} se nachází konstanty definující jak UI (barvy,
velikosti, fonty), tak i síťovou komunikaci (konkrétní názvy stavů, zprávy,
magic a oddělovač). V souboru \filename{common.py} se nachází definice tříd
Card, Player, Room. Kromě toho se tu vyskytuje i třída Client\_Dummy, která
existuje pouze kvůli rekurzivnímu vkládání - tato třída je proto v dědičnosti
rodičovskou třídě Client, která implemetuje konkrétní funkcionalitu.

\chapter{Uživatelská příručka}

Server by mělo být možné spustit na libovolné GNU/Linux zařízení, kde je možné
přeložit a spustit C++ 23, a kam může být připojena knihovna fmt. Pokud by byl
problém s knihovnou, tím že je použitá pouze pro logger můžete třídu Logger
upravit a o mnoho nepřijdete.

Kompilace/spuštění serveru: \input{partials/server_setup.tex}

Server lze nakonfigurovat v textovém souboru, který bude programu předaný při
spuštění. Formát souboru je: jedna konfigurační proměnná na řádek, mezerou
oddělená od hodnoty. Pokud se proměnná vyskytuje v souboru vícekrát, směrodatný
je její poslední výskyt.

\input{partials/config.tex}

Klientská aplikace je napsána v jazyku Python 3 a měla by být spustitelná na
jakémkoliv zařízení s interpretem pythonu v dané verzi a knihovnami pillow a
typing\_extensions. Doporučený postup je použít virtuální prostředí. Ukázkový
skript pro GNU/Linux Debian:

\input{partials/client_setup.tex}

Na MS Windows použijte ekvivalentní postup.

\chapter{Závěr}

Výsledná aplikace je dost robustní na problémy se sítí i uživatelem. Na začátku
projektu jsem se snažil o dokonalou architekturu serveru, ale nakonec to pro mě
bylo moc složité a raději jsem server navrhl jednoduše, ale pro mě
srozumitelně. Teď, po jeho dokončení, bych už nejspíš byl schopen dosáhnout
vyšší abstrakce a stále rozumět. Hlavní nevýhoda aktuální implementace je
svázanost klienta-hráče se socketem. Ideálně bych měl odděleně hráče a klienty,
přičemž pouze klient by byl svázán se socketem a hráč s maximálně jedním
klientem.

Přišlo mi nepříjemné implementovat herní logiku na duplicitně ve dvou jazycích.
Nevím, jestli existuje nějaké řešení, ale nechce se mi věřit, že by se takto
opravdu operovalo mimo školu.

Musím se pochválit za využití epollu na serveru - podařilo se mi tím vyhnout se
spoustě obtíží, které jsem slýchal od přátel.

\backmatter \backpage \end{document}
